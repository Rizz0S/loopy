#include "LoopyGraphState.h"
#include <fstream>
#include <sstream>

#include "LoopyNodeExceptions.h"
#include "BinaryPixelOperators.h"

void addInputFromNodeName(LoopyNode* node, string nodeKey, string inputNode, map<string, LoopyNode*> allNodes)
{
    // weak vs not weak
    if (inputNode.at(0) == '-') {
        node->addInput(allNodes[inputNode.substr(1)], nodeKey, false);
    } else {
        node->addInput(allNodes[inputNode], nodeKey, true);
    }
}

void LoopyGraphState::readGraphFromFile(string filename)
{
    cout << filename << endl;
    ifstream i(filename);
    cout << "YO2" << endl;
    json j;
    i >> j;
    destroyAutogeneratedNodes();
    parseJson(j);
    parseInputs(j);
}

void LoopyGraphState::destroyAutogeneratedNodes()
{
    for(size_t i = 0; i < autoGeneratedInputNodes.size(); ++i) {
        delete autoGeneratedInputNodes[i];
    }

    autoGeneratedInputNodes.clear();
}

void LoopyGraphState::destroyInputNodes()
{
    for(size_t i = 0; i < inputNodes.size(); ++i) {
        delete inputNodes[i];
    }

    inputNodes.clear();
}

void LoopyGraphState::destroyAll()
{
    destroyAutogeneratedNodes();
    destroyInputNodes();
    for(std::map<string, LoopyNode*>::iterator iter = allNodes.begin(); iter != allNodes.end(); ++iter) {
        delete iter->second;
    }

    allNodes.clear();
    output = NULL;
}

LoopyNode* setupBinaryNode(BinaryPixelOperator* op)
{
    BinaryNode* b = new BinaryNode(op);
    b->firstKey = "foregroundKey";
    b->secondKey = "backgroundKey";
    return b;
}
// this is super dumb but it'll do for now. there's a script that generates these names from a list of class names
void LoopyGraphState::parseJson(json& j)
{
    for (json::iterator it = j.begin(); it != j.end(); ++it) {
        string k = it.key();
        if (k == "output") {
            continue;
        }
        json o = it.value();
        string type = o["type"];
        if (allNodes.count(k) == 0) {
            if (type == "AdditionNode") {
                allNodes[k] = setupBinaryNode(new AddPixelOperator());
            }
            if (type == "AdditionModNode") {
                allNodes[k] = setupBinaryNode(new AddPixelModOperator());
            }
            if (type == "SubtractionNode") {
                allNodes[k] = setupBinaryNode(new SubtractPixelOperator());
            }
            if (type == "DivideNode") {
                allNodes[k] = setupBinaryNode(new DividePixelOperator());
            }
            if (type == "MultiplyNode") {
                allNodes[k] = setupBinaryNode(new MultiplyPixelOperator());
            }
            if (type == "ScaleNode") {
                allNodes[k] = new ScaleNode();
            }
            if (type == "TranslateNode") {
                allNodes[k] = new TranslateNode();
            }
            if (type == "RotateNode") {
                allNodes[k] = new RotateNode();
            }
            if (type == "SpeckledNoiseNode") {
                allNodes[k] = new SpeckledNoiseNode();
            }
            // if (type == "SineNode") {
            //     allNodes[k] = new SineNode();
            // }
            // if (type == "ClearImageNode") {
            //     allNodes[k] = new ClearImageNode();
            //     inputNodes.push_back((LoopyInputNode*)allNodes[k]);
            // }
            if (type == "ImageNode") {
                //This is a quick hack for right now to handle filenames as parameters.
                //I'm doing this right now because nodes can only have matrices as input.
                //That will change soon.
                string filename = o["params"]["file"];
                ImageNode *imgNode = new ImageNode();
                imgNode->setFileName(filename);
                allNodes[k] = imgNode;
                

            }
        }

        // try {
        //     allNodes[k]->setFunctionInputs(o["params"]);
        // } catch(exception& ex) {
        //     std::cout << ex.what() << std::endl;
        //     exit(1);
        // }
    }

    output = allNodes[j["output"]];
}

void LoopyGraphState::setupNumberNodeWithInput(float in, LoopyNode* parentNode, string paramName)
{
    LoopyNumberNode* num = new LoopyNumberNode();
    num->setOutput(in);
    allNodes[num->outputKey] = num;
    autoGeneratedInputNodes.push_back(num);
    addInputFromNodeName(parentNode, paramName, num->outputKey, allNodes);
}

/**
 * For every parameter in a node's 'params' object:
 * If the parameter value is a string, it references another node
 * If it a number or a boolean, autogenerate a new input node
 * and add it to all the necessary data structures.
 */
void LoopyGraphState::parseParams(LoopyNode* node, json& paramObject)
{
    for (json::iterator it3 = paramObject.begin(); it3 != paramObject.end(); ++it3) {
        string paramName = it3.key();
        json& paramObj = it3.value();
        if (paramObj.is_string()) {
            string p = paramObj;
            // FOR NOW, we will assume that when a string value exists
            // but it's not a node name, it's actually a file????
            if (allNodes.count(p) == 0) {
                //hackiest thing i've ever done
                LoopyInputNode* dummyInput = new LoopyInputNode();
                allNodes[dummyInput->outputKey] = dummyInput;
                inputNodes.push_back(dummyInput);
                addInputFromNodeName(node, paramName, dummyInput->outputKey, allNodes);
                continue;
            }
            addInputFromNodeName(node, paramName, p, allNodes);
        } else if (paramObj.is_number()) {
            float f = paramObj;
            setupNumberNodeWithInput(f, node, paramName);
        } else if (paramObj.is_boolean()) {
            bool b = paramObj;
            setupNumberNodeWithInput(b ? 1 : 0, node, paramName);
        } else {
            std::cout << "Parameters can only be strings, numbers, or booleans" << std::endl;
            exit(1);
        }
    }
}

/**
 * This is nasty but whatever
 * This is called after top-level nodes have been created
 * and stored in the proper data structures.
 * Now we go through each node and setup all input connections.
 * For parameter inputs, we autogenerate nodes when necessary
 * (when float/boolean constants appear in the input json)
 */
void LoopyGraphState::parseInputs(json& j)
{
    autoGeneratedInputNodes.clear();
    for (auto const &node : allNodes) {
        allNodes[node.first]->clearInputs();
    }
    // Loop through all this node's top-level dictionary entries
    for (json::iterator it = j.begin(); it != j.end(); ++it) {
        // Don't do anything to the output node. This gets handled elsewhere.
        if (it.key() == "output") {
            continue;
        }

        LoopyNode *n = allNodes[it.key()];

        for (json::iterator it2 = it.value().begin(); it2 != it.value().end(); ++it2) {
            string k = it2.key();
            if (k == "params") {
                json& paramObject = it2.value();
                parseParams(n, paramObject);
            } else if (k != "type") {
                string val = it2.value();
                addInputFromNodeName(n, k, val, allNodes);
            }
        }
    }
}
